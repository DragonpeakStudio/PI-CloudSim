#version 460 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout (binding = 0) writeonly restrict uniform image3D outVelocity;
layout (binding = 1) writeonly restrict uniform image3D outqc;
layout (binding = 2) writeonly restrict uniform image3D outqvAndTemp;

uniform sampler3D inVelocity; 
uniform sampler3D inqvAndTemp; 
uniform sampler3D inqc; 


#include "lib/rand.slib"
#include "lib/noise.slib"

uniform int side = 0;
uniform vec2 windValue = vec2(.1, .1);
uniform float baseTemperature = 300.;
uniform float bottomTemp = 10;
uniform float bottomQv = .1;
uniform int size = 0;
uniform float noiseScale = 20.;
uniform float time = 0.;
void main()
{
    ivec3 ipos = ivec3(gl_GlobalInvocationID.xyz);//doing a load of wasted calcs becuase i am so done
    vec3 res = vec3(gl_WorkGroupSize*gl_NumWorkGroups);
    vec3 pos = (vec3(gl_GlobalInvocationID.xyz)+.5)/res;

    //sides
    //vertical velocity zero
    //user defined windValue
    //user defined temperature
    //qc zero
    //qv periodic boundaries, what does this mean? I think it just loop to the other side

    //top free slip
    //user defined temp
    //qc zero
    //qv zero

    //bottom
    //no slip
    //qv and temp user defined with randomness

    if(ipos.z == res.z-1)//bottom
    {
        imageStore(outVelocity, ivec3(ipos), vec4(0));
        imageStore(outqc, ivec3(ipos), vec4(0));
        

        float qv = bottomQv*clamp(noise3D(vec3(pos.xy*noiseScale, time)), 0., 1.);
        float temp = baseTemperature+bottomTemp*clamp(noise3D(vec3(pos.xy*noiseScale, 123123+time)), 0., 1.);
        imageStore(outqvAndTemp, ivec3(ipos), vec4(qv, temp,0,0));//TODO randomness
    }
    else if(ipos.z == 0)//top
    {
        imageStore(outqc, ivec3(ipos), vec4(0));
        imageStore(outqvAndTemp, ivec3(ipos), vec4(0, baseTemperature, 0,0));
        imageStore(outVelocity, ivec3(ipos), vec4(texture(inVelocity, vec3(pos.xy, 0)).xy, 0, 0));
    }
    else if(ipos.x == 0 || ipos.x == res.x-1 || ipos.y == 0 || ipos.y == res.y-1)//side
    {
        vec3 altPos3 = vec3(0);
        if(ipos.x == 0)
        {
            altPos3 = vec3(res.x-2, pos.y, ipos.z)/vec3(res);
        }
        else if(ipos.x == res.x-1)
        {
            altPos3 = vec3(1, pos.y, ipos.z)/vec3(res);
        }
        if(ipos.y == 0)
        {
            altPos3 = vec3(pos.x, res.y-2, ipos.z)/vec3(res);
        }
        else if(ipos.y == res.x-1)
        {
            altPos3 = vec3(pos.x, 1, ipos.z)/vec3(res);
        }//why won'y you just work!
        float qc = texture(inqc, vec3(altPos3)).x;
        imageStore(outqc, ipos, vec4(qc));
        imageStore(outVelocity, ipos, vec4(windValue, 0, 0));
        float qv = texture(inqvAndTemp, vec3(altPos3)).x;
        imageStore(outqvAndTemp, ipos, vec4(qv, baseTemperature,0,0));

    }
    
}